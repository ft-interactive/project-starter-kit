/**
 * @file
 * This is the main server entry point.
 *
 * It is used to build the project initially; afterwards, the client code hydrates
 * the code generated by this file.
 *
 * You shouldn't need to mess with it, generally.
 */

import 'undom/register';
import './register'; // Remove when o- deps are fixed.
import React from 'react';
import { renderToString } from 'react-dom/server';
import { HtmlHead } from '@financial-times/g-components';
import criticalPath from '@financial-times/g-components/shared/critical-path.scss';
import App from '../client/app';

export default (context) => {
  const { buildTime, id, testCommentsUuid } = context;
  // These get added to the opening <html> element below.
  const htmlAttributes = Object.entries({
    lang: 'en-GB',
    class: 'core',
    'data-buildtime': buildTime,
    'data-content-id': process.env.NODE_ENV === 'production' ? id || testCommentsUuid : id || '',
  }).map(([k, v]) => `${k}="${v}"`);

  /*
    Here's where we generate the server-side template. We render the g-components
    <HtmlHead> element as a string (it contains wrapping <head> elements), then
    stringify the entire React app inside of body > #app.

    Later, in the client-side code, the stringified React app gets updated ("hydrated")
    with current state. This is probably overkill for most IG projects but will be
    useful in anything even slightly more advanced.
   */

  return `
    <!doctype html>
    <html ${htmlAttributes.join(' ')}>
      <script>window.__STATE__ = ${JSON.stringify(context)}</script>
      <!-- Critical path CSS -->
      <link rel="stylesheet" href="${criticalPath}" />
      ${renderToString(<HtmlHead {...context} />)}
      <body>
        <div id="app">${renderToString(<App {...context} />)}</div>
      </body>
    </html>
  `.trim();
};
